# 소코반(Sokoban) 게임 구현하기
> + 캐나다 방송 협회(cbc) 게임 웹 사이트의 "소코반 게임" 구현
> > + 1단계 : 지도 데이터 읽어서 2차원 배열에 저장하고 화면에 출력
> >   + [1단계 구현과정 상세 설명](#1단계-구현과정-상세-설명)
> > + 2단계 : 지도 내 플레이어의 단순 이동 구현(위, 아래, 왼쪽, 오른쪽)
> >   + [2단계 구현과정 상세 설명](#2단계-구현과정-상세-설명)
> > + 3단계 : 지도 내 플레이어의 이동 조건 구현(벽 이동 제한, 공 구멍으로 밀기, 공 구멍 밖으로 밀기 등)
> >   + [3단계 구현과정 상세 설명](#3단계-구현과정-상세-설명)
> > + 4단계 : 저장하기(save) 및 불러오기(load), 지도 데이터 암호화 및 해독, 되돌리기(redo) 및 되돌리기 취소(undo) 기능 구현
> >   + [4단계 구현과정 상세 설명](#4단계-구현과정-상세-설명)
> > 
> + 참고 : https://www.cbc.ca/kids/games/play/sokoban

<br/>
<hr>
<br/>

# 1단계 구현과정 상세 설명

## 1단계
> ### 풀이 과정
>	> + #### 전체 클래스 구성
>	>
>	> >  + Sokoban 클래스(main 클래스)
>	> >  + StageMap 클래스(지도 데이터 읽기, 출력)
>	> >  + MapData 클래스(스테이지별 지도 데이터 저장 및 전송)
>	>	>
>	> >  + 클래스 다이어그램
>	> > ![캡처](https://user-images.githubusercontent.com/82401504/144848276-0bd13d17-a041-4bba-9fb5-5fda0aa6d1dd.PNG)
>	>
>	> + #### 풀이 과정
>	> >  + 하나의 소스 파일에 절차식으로 코드를 작성하기 보다 기능별로 분리하여 코드를 작성하고자 했습니다.
>	> >    + 기능별로 첫째, main 클래스 역할을 하는 Sokoban 클래스, 둘째, 지도 데이터를 읽어오고 출력하는 StageMap 클래스, 셋째, 콘솔창으로부터 지도 데이터를 입력받을 때와 콘솔창에 지도 데이터를 출력시킬 때를 위해 데이터를 저장하고 전송하는 용도의 MapData 클래스로 나누어 코드를 작성했습니다.
>	>	>
>	> >  + main 메서드를 포함하고 있는 Sokoban 클래스에서 StageMap 객체를 생성하여 createMap 메서드를 통해 콘솔창으로부터 지도 데이터 리스트를 입력받도록 했고, 이를 인자로 두어 showMap 메서드를 통해 콘솔창에 지도 데이터를 출력시키도록 했습니다.
>	> >    + 이때 createMap 메서드가 실행될 때는 MapData 객체를 생성하여 지도 데이터를 입력받도록 했습니다. 마찬가지로 showMap 메서드 실행 시(출력 시)에는 데이터가 저장된 MapData 객체로부터 데이터를 꺼내와 데이터를 콘솔창에 출력하도록 했습니다.

<br/>
<hr/>
<br/>

> ### 코드 설명
>	> + #### Sokoban 클래스(main 클래스)
>	> >  + Sokoban 클래스는 해당 프로그램의 메인 클래스로서 main 메서드를 포함하고 있습니다.
>	> >  + 또한, 스테이지별로 지도의 가로 길이와 세로 길이를 2차원 배열(map_size)에 저장하고 있습니다.
>	> >    + 해당 코드에서는 2개의 스테이지에 대해 크기를 설정했습니다.
> > >  ```Java
> > >  int[][] map_size = {{3, 5}, {7, 11}};
> > >  ```
>	> >  + StageMap 객체를 생성한 후 2차원 배열(map_size)을 인자로 두어 createMap 메서드를 호출하여 스테이지별로 지도 데이터를 읽어오고, 리스트(mapData_list)에 저장합니다. 
>	> >  + 이후 해당 리스트(mapData_list)를 인자로 두어 showMap 메서드를 호출하여 스테이지별로 지도 데이터를 출력합니다.
> > >  ```Java
> > >  StageMap stageMap = new StageMap();
> > >  List<MapData> mapData_list = stageMap.createMap(map_size);
> > >  stageMap.showMap(mapData_list);
> > >  ```
>	>
>	> + #### StageMap 클래스(지도 데이터 읽기, 출력)
>	> >  + StageMap 클래스는 hashMap 필드와 StageMap 생성자 그리고 createMap 메서드, showMap 메서드, getMapData 메서드로 구성되어있습니다.
>	> >  + 우선 hashMap 필드는 지도 데이터(#, O, o 등)별로 변환값(0 ~ 4)을 저장하는 역할을 하며, StageMap 생성자 호출 시(StageMap 객체 생성 시) 각각의 데이터별로 변환시킬 값을 put 해주었습니다.
>	> >    + 이는 콘솔창으로부터 데이터를 입력받을 때 사용되고(#, O, o 등 -> 0 ~4) 이후 가공, 처리된 데이터를 콘솔창에 출력시킬 때 사용됩니다.(0 ~4 -> #, O, o 등)
> > >  ```Java
> > >  Map<Character, Integer> map_data_value;
> > >  
> > >  public StageMap() {
> > >   // 지도 데이터별 변환값
> > >   this.map_data_value = new HashMap<>();
> > >   map_data_value.put('#', 0);
> > >   map_data_value.put('O', 1);
> > >   map_data_value.put('o', 2);
> > >   map_data_value.put('P', 3);
> > >   map_data_value.put('=', 4);
> > >  }
> > >  ```
> > >  + createMap 메서드는 Scanner 객체를 통해 콘솔창으로부터 지도 데이터를 입력받아 스테이지별 지도 데이터를 저장하는 역할을 합니다.
> > >    + 이때 MapData 객체(mapData)를 생성하여 여기에 스테이지별로 스테이지명과 변환된 지도 데이터를 저장하고 이를 최종적으로 MapData 객체 리스트(mapData_list)에 저장(setter 메서드)하고 이를 반환합니다.
> > >    + 또한 Sokoban 클래스로부터 2차원 정수형 배열(map_size)을 파라미터로 받고 있는데 이는 스테이지별 가로/세로 크기를 저장하고있으며, 이를 통해 위에서 mapData 객체에 지도 데이터를 저장하기 전에 먼저 지도 데이터를 입력받을 저장할 2차원 배열의 크기를 설정합니다.
> > >  + showMap 메서드는 위에서 생성된 MapData 객체 리스트를 파라미터로 받아, MapData 객체별로(스테이지별로) 스테이지 명과 지도 데이터를 얻어와(getter) 콘솔창에 출력하는 역할을 합니다.
> > >    + 이때 얻어오는 지도 데이터는 변환된 값(0~4)으로 저장되어 있었기 때문에 이를 다시 처음 값(#, O, o 등)으로 되돌려 주어야 합니다.
> > >    + 이를 위해 별도 getMapData 메서드를 통해 value(0~4)에 해당하는 key(#, O, o 등)이 존재하는 경우 key를 얻고, 해당되는 게 없는 경우 ' '(공백)을 얻어왔습니다.
> > >  ```Java
> > >  // hashmap의 value 로 key 찾기
> > >  public char getMapData(int value) {
> > >  
> > >  // value와 일치하는 key 반환
> > >  for (Character key : this.map_data_value.keySet()) {
> > >       if (value == this.map_data_value.get(key)) {
> > >           return key;
> > >       }
> > >   }
> > >   // value와 일치하는 key가 없는 경우 ' ' 반환
> > >   return ' ';
> > >  }
> > >  ```
> >
> > + #### MapData 클래스(스테이지별 지도 데이터 저장 및 전송)
> > >  + MapData 클래스는 콘솔창으로부터 입력받은 데이터를 저장하고 이를 가공, 처리하여 콘솔창에 출력하는 과정에서 "저장"과 "전송"의 역할을 하고있습니다.
> > >  + 문자열 stage_name 필드는 스테이지명(Stage 1, Stage 2, ...)을 저장할 때 2차원 정수형 배열 map_data 필드는 변환된 지도 데이터 값(0~4)를 저장할 때 사용됩니다.
> > >    + 이때 MapData 객체에 데이터를 저장할 때는 setter 메서드를 사용했고 데이터를 전송할 때는 getter 메서드를 사용했습니다.
> > > ```Java
> > >     private String stage_name;
> > >     private int[][] map_data;
> > > 
> > >     public String getStage_name() {
> > >         return stage_name;
> > >     }
> > > 
> > >     public int[][] getMap_data() {
> > >         return map_data;
> > >     }
> > > 
> > >     public void setStage_name(String stage_name) {
> > >         this.stage_name = stage_name;
> > >     }
> > > 
> > >     public void setMap_data(int[][] map_data) {
> > >         this.map_data = map_data;
> > >     }
> > > ```
  
<br/>
<hr/>
<br/>

> ### 실행 결과
> > #### 입력 시 고려사항
>	> >  + 지도 데이터를 입력 시 스테이지별 지도에 따라 줄마다 존재하는 문자의 개수가 다를 수 있기 때문에 지도 데이터를 입력 받아오기 전 스테이지별로 지도의 가로, 세로 길이 크기를 저장(int[][] map_size)했습니다. 이를 통해 지도 데이터를 저장할 2차원 정수형 배열(int[][] map_data)을 선언 및 생성하고 모든 요소를 공백(' ')으로 초기화시켰습니다. 이 이유는 지도 데이터의 특정 줄 마지막 열 부근에 공백이 빠진채로 입력되는 것을 방지하기 위함입니다.
>	> >    + 예를 들어, 가로 길이가 5인 지도가 주어질 때 콘솔창에 줄마다 "#####"와 같이 5개의 문자로 이루어지면 다행이지만, "###"와 같이 1-3열은 #, 4-5열은 어떤 값도 없는 경우(trim, 양 끝 공백 삭제)도 있을 수 있기 때문입니다.
> > > ```Java
> > >   // 스테이지별 지도의 가로, 세로 길이 크기 설정
> > >   int[][] map_size = {{3, 5}, {7, 11}};
> > > ```              
>	> >  + 또한, 구분선의 경우 마지막 스테이지를 제외하고 나머지 모든 스테이지 지도 데이터 가장 하단에 4 값(변환값)으로 저장되게 되는데 이를 위해 당초 크기 설정했던 것에서 세로 길이를 1씩 증가시켜주었습니다.
> > > ```Java
> > >   // 구분선을 저장하기 위해 스테이지별 세로 길이 1씩 증가(마지막 스테이지 제외)
> > >   for (int i = 0; i < map_size.length - 1; i++) {
> > >       map_size[i][0]++;
> > >   }
> > > ```
> > #### 출력 시 고려사항
>	> >  + 입력에서 지도 데이터 2차원 정수형 배열(int[][] map_data)의 요소를 공백(' ')으로 초기화시켰으므로 요소 값이 공백(' ')이라면 아래 코드를 작업하지 않도록 continue 시켰습니다. 또한 플레이어의 위치는 배열 인덱스 0, 0을 1, 1 기준으로 보고있기 때문에 플레이어의 위치를 출력 시에는 각각의 위치(player_posx, player_posy)의 값을 +1 해주었습니다.
> > > ```Java
> > > if (elem == ' ') continue;
> > > else if (elem == 'O') hole_cnt++;
> > > else if (elem == 'o') ball_cnt++;
> > > else if (elem == 'P') {
> > >     player_posx = j+1;
> > >     player_posy = i+1;
> > > }
> > > ```
>	> >  + 입력과 마찬가지로 출력에서도 구분선을 신경써주어야 했는데, 2중 for문의 내부 for문(열)에서 지도 데이터 요소 값이 '='이라면 그 즉시 해당 for문을 빠져나오도록 하여(break) 출력시키지 않도록 구현했습니다. 또한 구분선을 포함하지 않는 경우 콘솔창에서 마지막행의 개행이 이루어지지 않으므로 가로, 세로 길이 등 정보를 나타내는 출력 부분과 딱 붙게 되어 심미성이 떨어지게 되므로 break 시 당초 false로 선언한 flag(boolean형)에 true를 할당하여 구분선이 없는 마지막 스테이지의 경우 개행이 일어나도록 했습니다. 또한 세로 길이 역시 구분 기호를 포함하는 경우(flag = true) -1 해주었습니다.
> > > ```Java
> > > boolean flag = false; // 구분선을 포함하고 있는지 여부
> > > // (...생략...)
> > > // 구분선을 포함하고 있으면 출력하지 않음
> > > if (elem == '=') {
> > >     flag = true;
> > >     break;
> > > }
> > > // (...생략...)
> > > if(!flag) System.out.println();
> > > // (...생략...)
> > > if(flag) // 구분 기호를 포함하는 경우
> > >     System.out.printf("세로크기: %d%n", data.length-1);
> > > else // 구분 기호를 포함하지 않는 경우
> > >     System.out.printf("세로크기: %d%n", data.length);
> > > ```
> > #### 실행 결과
> > ##### 입력
> > >  ```
> > > Stage 1
> > > #####
> > > #OoP#
> > > #####
> > > =====
> > > Stage 2
> > > #######
> > > ###  O  ###
> > > #    o    #
> > > # Oo P oO #
> > > ###  o  ###
> > > #   O  # 
> > > ########
> > > ```
> > ##### 출력
> > > ```
> > > Stage 1
> > > 
> > > #####
> > > #OoP#
> > > #####
> > > 
> > > 가로크기: 5
> > > 세로크기: 3
> > > 구멍의 수: 1
> > > 공의 수: 1
> > > 플레이어 위치 (2, 4)
> > > 
> > > Stage 2
> > > 
> > >   #######  
> > > ###  O  ###
> > > #    o    #
> > > # Oo P oO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > 
> > > 가로크기: 11
> > > 세로크기: 7
> > > 구멍의 수: 4
> > > 공의 수: 4
> > > 플레이어 위치 (4, 6)
> > > 
> > > ```
              

<br/>
<hr/>
<br/>
  
# 2단계 구현과정 상세 설명

## 2단계
> ### 풀이 과정
> > + #### 전체 클래스 구성
> >
> > >  + Sokoban 클래스(main 클래스)
> > >  + StageMap 클래스(지도 데이터 읽기, 출력)
> > >  + MapData 클래스(스테이지별 지도 데이터, 플레이어 위치 정보 저장 및 전송)
> > >  + GamePlay 클래스(지도 데이터 출력, 플레이어 이동)
> >	>
> > >  + 클래스 다이어그램
> > > ![캡처1](https://user-images.githubusercontent.com/82401504/145070804-5b725c06-9f86-439a-8564-e974f29b23d6.PNG)
> >
> > + #### 풀이 과정
> > >  + 1단계와 마찬가지로 기능별로 분리하고 최대한 기존의 코드를 재사용하고자 했습니다.
> > >    + 기존 지도 데이터를 활용하기 위해 데이터 저장 및 전송 역할을 하는 MapData 클래스를 재사용하고, 게임 진행 시 지도 데이터를 출력하기 위해 StageMap 클래스의 getMapData 메서드를 재사용했습니다.
> > >  + 반복적인 명령어에 따라 플레이어의 이동을 구현하기 위해서는 플레이어의 이동을 나타내는 역할의 moveMap 메서드를 작성하고 이 메서드 내에서는 while-true문을 사용했습니다.
> > >    + 또한, 각각의 명령어(이동방향 wasd, 종료 q)에 따라 플레이어의 이동 패턴이 다를 것이므로 명령어들을 체크하는 checkCommand 메서드를 작성하여 반복문 내에서 이를 호출하도록 구현했습니다.

<br/>
<hr/>
<br/>

> ### 코드 설명
> > 
> > + #### Sokoban 클래스(main 클래스)
> > >  + 1단계 "지도 데이터 출력하기" 후 Sokoban 클래스 main 메서드는 GamePlay 객체를 생성하여 showMap 메서드(지도 데이터 출력)를 호출함으로써 게임 시작을 알리고(콘솔창에 해당 스테이지 지도 데이터 출력), moveMap 메서드를 추가로 호출하여 플레이어의 이동을 구현하도록 했습니다.
> > >    + 이 과정에서 1단계에서 얻은 MapData 리스트에서 해당 스테이지(여기서는 Stage 2)에 해당하는 MapData를 추출하여(get) 각각의 메서드에 인자로 전달해주었는데, 이 데이터는 지도 데이터를 출력하거나, 플레이어의 위치 정보를 기억하기 위해 사용되었습니다.
> > >    + 또한, 출력하는 데이터간 큰 차이가 존재하여 StageMap 클래스의 showMap 메서드를 완전히 재사용할 수 없었으나, GamePlay 객체의 showMap 메서드에서 StageMap 클래스의 지도 데이터 요소를 가져오는 getMapData 메서드를 재사용할 수 있었습니다.
> > > ```Java
> > >     // Gameplay 클래스의 showMap 메서드
> > >     public void showMap(int[][] data){
> > > 
> > >         char elem; // 지도 데이터 요소
> > > 
> > >         StageMap stageMap = new StageMap(); // StageMap 객체 생성
> > > 
> > >         // 변환된 지도 데이터 값을 다시 원래대로 변환하여 콘솔창에 출력
> > >         for (int i = 0; i < data.length; i++) {
> > >             for (int j = 0; j < data[0].length; j++) {
> > >                 elem = stageMap.getMapData(data[i][j]); // getMapData 메서드 재사용
> > >                 // 구분선을 포함하고 있으면 출력하지 않음
> > >                 if (elem == '=') break;
> > >                 System.out.print(elem);
> > >             }
> > >             System.out.println();
> > >         }
> > >         System.out.println();
> > >     }
> > > ```
> >
> >  + #### StageMap 클래스(지도 데이터 읽기, 출력)
> > >  + StageMap 클래스의 showMap 메서드는 처음 지도를 생성하는 경우 지도 데이터에 대한 정보(구멍의 개수, 공의 개수, 플레이어의 위치 등)들을 출력하고 있는데, 이 정보를 활용하여 해당 MapData 객체에 플레이어의 처음 위치를 초기화 시켜주었습니다. 이는 나중에 플레이어가 움직일 때마다 처음 위치를 기준으로 x축, y축 각각의 방향으로 각각 증감시키기 위함입니다.
> > > ```Java
> > >     int[] player_pos = {player_posy-1, player_posx-1};
> > >     map.setPlayer_pos(player_pos);
> > > ```
> >
> >  + #### MapData 클래스(스테이지별 지도 데이터, 플레이어 위치 정보 저장 및 전송)
> > >  + GamePlay 클래스에서 하나의 명령어가 주어진 이후 다음 명령어가 주어질 때 변경된 플레이어의 위치를 기억해야하는데, 이를 위해 MapData 클래스에 플레이어 위치(x, y)를 저장하는 1차원 정수형 배열을 필드로 추가시켰습니다.
>	> >    + checkCommand 메서드의 반환형은 MapData 객체인데 이는 함수 종료 직전 변경된 플레이어의 위치를 MapData 객체에 저장한 후 다시 while-true문에서 다음 명령어를 체크하기 전에 플레이어의 위치를 변경하도록 했습니다.
> > > ```Java
> > >         char[] commands;
> > >         while(true){
> > >             System.out.print("w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료) 중 하나 이상 입력해주세요 : ");
> > >             commands = sc.nextLine().toCharArray();
> > >             for (int i = 0; i < commands.length; i++) {
> > >                 if(commands[i] == 'q') {
> > >                     System.out.println("게임을 종료합니다.");
> > >                     return;
> > >                 }
> > >                 MapData mapData = checkCommand(map_data, player_pos, commands[i]);
> > >                 map_data = mapData.getMap_data();
> > >                 player_pos = mapData.getPlayer_pos();
> > >                 showMap(map_data);
> > >             }
> > >         }
> > > ```
> > 
> >  + #### GamePlay 클래스(지도 데이터 출력, 플레이어 이동)
> > >  + GamePlay 클래스의 moveMap 메서드는 플레이어의 이동을 구현하는 역할을 하도록 했습니다. 이때 while-true 문을 이용하여 반복적으로 명령어(이동방향 wasd, 종료 q)를 입력 받도록 했습니다.
> > >    + 또한 명령어를 체크하기 위한 checkCommand 메서드를 별도 작성했습니다. checkCommand 메서드에서는 코드의 가독성을 좀 더 높이고자 switch-case문을 사용했고 이동하려는 위치가 공백(32 값)일 경우 플레이어를 해당 위치로 이동시킨 후 기존 플레이어의 위치는 공백(32 값) 처리했습니다. 만일 이동하려는 위치가 공백이 아닐 경우 경고 메시지를 출력하면서 아무런 동작이 이루어지지 않습니다. 아울러, 유효한 명령어 외 다른 명령어를 입력할 경우 switch-case문 내 default를 선언하여 경고 메시지를 출력합니다.(유효한 명령어의 경우 swich-case문 내 break로 default 실행 안 됨)
  
<br/>
<hr/>
<br/>

> ### 실행 결과
> > #### 출력 시 고려사항
> > > + 프로그램이 시작되면 플레이어가 게임시작 된 걸 알 수 있도록 "Game Start!!"라는 메시지와 함께 해당 스테이지(여기서는 Stage 2)의 지도 데이터가 콘솔창에 출력하도록 했습니다. 또한 플레이어가 어떤 명령어를 입력해야할지 모를 수 있으므로 게임이 시작되고 명령어를 입력받을 때 명령어에 대한 안내 메시지를 출력시켰습니다.
> > > + 특정 방향으로 이동시 현재 위치를 명확히 알 수 있도록 아래 화살표 표시를 했고(연속적으로 명령어가 입력될 시 콘솔창 상 위 지도 데이터와 아래 지도 데이터가 헷갈림) 플레이어가 구멍, 공 등 이동할 수 없는 위치로 이동 시 경고메시지를 콘솔창에 출력시켰습니다. 또한 wasdq 외의 명령어를 입력한 경우 역시 경고메시지를 콘솔창에 출력시켰습니다.
> > >   + 콘솔창에 명령어 입력 메시지, 이동/경고 메시지, 지도 데이터 등 여러가지 사항들이 출력되고 있으므로 위 아래 내용이 헷갈릴 수 있으므로 하나의 작업 단위별로 출력되도록 문장을 개행시켰습니다.
> > #### 실행 결과(1단계 입출력 생략)
> > > ```
> > > Game Start!!
> > > Stage 2
> > > 
> > >   #######  
> > > ###  O  ###
> > > #    o    #
> > > # Oo P oO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > 
> > > w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료) 중 하나 이상 입력해주세요 : dd
> > > 오른쪽으로 이동합니다. 현재 위치 ↓ 
> > >   #######  
> > > ###  O  ###
> > > #    o    #
> > > # Oo  PoO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > 
> > > (경고) 해당 명령을 수행할 수 없습니다!!  현재 위치 ↓ 
> > >   #######  
> > > ###  O  ###
> > > #    o    #
> > > # Oo  PoO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > 
> > > w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료) 중 하나 이상 입력해주세요 : x
> > > (경고) 잘못된 값을 입력했습니다!! 현재 위치 ↓ 
> > >   #######  
> > > ###  O  ###
> > > #    o    #
> > > # Oo  PoO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > 
> > > w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료) 중 하나 이상 입력해주세요 : q
> > > 게임을 종료합니다.
> > > ```

<br/>
<hr/>
<br/>

# 3단계 구현과정 상세 설명

## 3단계
> ### 풀이 과정
> > + #### 전체 클래스 구성
> >
> > >  + Sokoban 클래스(main 클래스)
> > >  + StageMap 클래스(지도 데이터 읽기, 출력)
> > >  + MapData 클래스(스테이지별 지도 데이터, 플레이어 위치 정보 저장 및 전송)
> > >  + GamePlay 클래스(지도 데이터 출력, 플레이어의 이동 및 조건, 초기화 등 부가 기능)
> >	>
> > >  + 클래스 다이어그램
> > > ![캡처2](https://user-images.githubusercontent.com/82401504/145070691-b19b10fd-880d-48f4-875e-294ba06c8ab5.PNG)

> >
> > + #### 풀이 과정
> > >  + 실제 소코반 게임(https://www.cbc.ca/kids/games/play/sokoban) 상의 Stage 3-5(Stage 1-2는 그대로)의 지도를 그대로 구현하여 map.txt 파일에 작성하고 이를 StageMap 클래스 createMap 메서드에서 FileReader 객체를 생성하여 읽어오도록 했습니다.
> > >    + StageMap 객체로부터 얻은 지도 데이터 MapData 객체 리스트를 for문을 통해 Stage 1부터 실행되도록 구현했고 종료 조건(게임을 중간에 종료하거나 모든 스테이지를 완료한 경우)을 별도로 설정해주었습니다.
> > >  + 스테이지별로 게임이 실행될 때 moveMap 메서드가 해당 MapData 객체를 받도록 하여 이를 통해 각 명령문(wasd)에 따라 플레이어의 이동 조건을 checkCommand 메서드에서 구현했고 해당 스테이지가 클리어 되는 조건을 checkClear 메서드에서 구현했습니다.
> > >    + 이때, 플레이어가 공을 밀거나 플레이가 구멍 위를 지나가는 경우 구멍이 사라졌다가 생기는 것을 구현하기 위해 moveMap 메서드에서 최초 스테이지 지도 데이터를 별도로 저장하여(map_data_origin) 이를 비교함으로써 지도 데이터를 바꾸어 주었습니다.
> > >    + 또한, 초기화 명령문(r)에 따라 초기화 시킬 때 역시 현재 지도 데이터를 위에서 저장한 최초 스테이지 지도 데이터로 변환시켜주었습니다.

<br/>
<hr/>
<br/>

> ### 코드 설명
> > 
> > + #### Sokoban 클래스(main 클래스)
> > >  + 2단계에서와 달리 이번 단계에서는 StageMap 객체로부터 반환받은 MapData 객체 리스트를 하나만 꺼내와서 사용하는 것이 아니라 for문을 통해 Stage 1 ~ Stage 5까지 순차적으로 실행시켜 주었습니다.
> > >    + 각 스테이지별로 게임이 시작되면 "Game Start!!" 메시지와 Stage명 메시지와 함께 해당 지도 데이터(GamePlay 객체의 showMap 메서드를 통해)를 콘솔창에 출력시켜주었습니다.
> > >  + 이후 해당 스테이지의 지도 데이터를 인자로 두어 GamePlay 객체의 moveMap 메서드를 호출시켜 게임이 진행되도록 했습니다.
> > >    + 이때 boolean형 변수 quit_flag을 선언하여 사용자가 게임을 종료시키는 경우 해당 for문을 break하도록 했고 사용자가 게임을 종료하지 않고 for문을 빠져나왔다는 것은 모든 스테이지를 다 클리어한 경우에만 해당되므로 축하메시지를 출력시켰습니다.
> > > ```Java
> > >         MapData mapData;
> > >         GamePlay gamePlay;
> > >         boolean quit_flag = false;
> > >         int last_level = mapData_list.size();
> > > 
> > >         for (int i = 1; i <= last_level; i++) {
> > >             System.out.println("Game Start!!");
> > >             System.out.printf("Stage %d%n", i);
> > >             System.out.println();
> > > 
> > >             mapData = mapData_list.get(i-1);
> > >             gamePlay = new GamePlay();
> > > 
> > >             gamePlay.showMap(mapData.getMap_data());
> > >             quit_flag = gamePlay.moveMap(mapData);
> > >             if(quit_flag) break;
> > >         }
> > > 
> > >         if(!quit_flag) System.out.println("축하합니다!! 모든 스테이지를 클리어 했습니다!!");
> > > ```
> > 
> >  + #### StageMap 클래스(지도 데이터 읽기, 출력)
> > >  + 3단계에서는 구멍 위에 있는 공(0)에 대한 정보를 처리하는 일이 생기므로 기존 지도 데이터의 변환값을 저장하고 있는 HashMap 자료구조에 해당 정보를 추가시켜주었습니다. 또한, 2단계와 달리 입력을 txt 파일로부터 받기 위해 FileReader 객체를 생성하여 이를 읽어왔습니다. 이때 BufferedReader의 readLine()를 사용했는데, 이는 buffer를 사용하기 때문에 FileReader보다 좀 더 빠르게 파일을 읽어올 수 있기 때문입니다.
> > > ```Java
> > >    public StageMap() {
> > >        // 지도 데이터별 변환값
> > >        map_data_value = new HashMap<>();
> > >        map_data_value.put('#', 0);
> > >        map_data_value.put('O', 1);
> > >        map_data_value.put('o', 2);
> > >        map_data_value.put('P', 3);
> > >        map_data_value.put('=', 4);
> > >        map_data_value.put('0', 5);
> > >    }
> > > ```
> > 
> >  + #### GamePlay 클래스(지도 데이터 출력, 플레이어의 이동 및 조건, 초기화 등 부가 기능)
> > >  + GamePlayt 클래스의 moveMap 메서드는 Sokoban 클래스에서 호출하면서 스테이지별로 MapData 객체를 파라미터로 받는데, 우선 최초 지도 데이터를 이차원 정수형 배열 map_data_origin에, 최초 플레이어 위치를 일차원 정수형 배열 player_pos에 저장시켜주었습니다. 이는 나중에 사용자가 게임을 초기화하거나 구멍의 위치를 기억하기 위해 사용되기 때문입니다.
> > >  + 명령어가 입력되기 시작하면 2단계에서와 마찬가지로 while-true문이 실행되는데 게임을 종료시키면(명령어 q) true를 반환시키고 있습니다. 그 이유는 true를 받환받은 Sokoban 클래스에서는 이를 게임 자체를 종료시키는 것으로 인식하기 때문입니다.(MapData 객체 리스트 for문에서 break)
> > >  + 또한, 스테이지를 초기화 시키면(명령어 r) 앞서 저장했던 최초 지도 데이터 및 플레이어의 위치를 통해 현재 지도 데이터와 플레이어의 위치를 초기화 시켰습니다. 턴수(turn) 역시 0으로 초기화시켜주었습니다.
> > >    + 이 동작이 완료 되면 명령어를 체크하는 메서드 checkCommand 등을 실행할 필요가 없으므로 그대로 continue시켰습니다.
> > >  + 그 외 명령어(w 위쪽, a 왼쪽, s 아래쪽, d 오른쪽)가 입력되면 checkCommand 메서드가 실행되는데 해당 명령어에 따라 x(1씩), y(1씩), x_(2씩), y_(2씩)값을 증감시켜 플레이어 위치를 기준으로 해당 방향(w, a, s, d) 앞에 있는 물체가 공인지, 벽인지 등을 체크시켰습니다.
> > >    + 앞서 2단계에서 이 부분을 switch-case문으로 구현했으나 코드가 길어지는 감이 있어 위와 같이 리팩토링하였습니다.
> > >  + 복잡한 조건에 있는 경우를 먼저 생각해보았습니다. 우선 플레이어 앞에 있는 물체가 공(2)이거나 구멍위에 있는 공(5)인 경우 보다 한 칸 더 앞에 있는 물체가 아무것도 없거나(32) 빈 구멍(1)인 경우 공을 밀 수 있습니다. 이때 빈 구멍(1)인 경우 그 위치는 밀린 공에 의해 구멍 위에 있는 공(5)으로 바뀌게 되고 아무것도 없는 경우(32) 그냥 공(2)으로 바뀝니다.
> > > ```Java
> > > if((frontObj == 2 || frontObj == 5) && (moreFrontObj == 32 || moreFrontObj == 1)) {
> > >     if (moreFrontObj == 1) data[row+x_][col+y_] = 5; // 구멍이 공에 가려진 경우
> > >     else data[row+x_][col+y_] = 2;
> > > } 
> > > ```
> > >  + 또한 앞에 있는 물체가 벽(0)이면 당연히 못 움직이므로 경고 메시지와 함께 null을 반환 시켰고(해당 메서드에서는 변경된 지도 데이터 MapData 객체를 반환하고 있습니다.) 앞에 공(2)이나 구멍 위에 있는 공(5)이 있어도 한 칸 더 앞에 있는 공간이 구멍도 아니고 빈 공간이 아니라면 공을 밀 수 없으므로 마찬가지로 null을 반환시켰습니다.
> > > ```Java
> > > else if(frontObj == 0 || ((frontObj == 2 || frontObj == 5) && (moreFrontObj != 1 || moreFrontObj != 32))) {
> > >     System.out.printf("(경고) 해당 명령을 수행할 수 없습니다!!%n");
> > >     return null;
> > > }
> > > ```
> > > + 위의 조건을 통과하고 나면 플레이어는 해당 명령어에 의해 위치를 변경시킬 수 있다는 것을 의미합니다. 이에 기존 플레이어의 위치를 공백(0)으로 만들어주고 끝내면 좋지만 플레이어가 구멍(1)을 밟고 있었거나 맨 처음부터 구멍 위에 공이 있었던 자리(5)에 있었을 경우에는 이를 구멍(1)으로 만들어주어야 합니다.
> > >   + 플레이어가 구멍을 밟고 있으면 현재 지도 데이터 상으로는 구멍인지를 인식할 수 없으므로(플레이어 변환값인 3으로 인식하기 때문) 오리지날 데이터를 활용하여 비교했습니다.(구멍의 위치는 변하지 않기 때문에)
> > > + 앞서 변경된 지도 데이터와 플레이어 위치를 다시 MapData 객체에 저장하여 이를 반환시켰습니다. 이때 성공적으로 명령어가 수행되었으므로 턴수(trun)를 1 증가시켜주었습니다. 이제 새로운 지도 데이터를 출력하고 해당 게임이 클리어 조건을 충족시켰는지를 checkClear 메서드를 통해 확인했습니다.
> > >   + checkClear 메서드는 지도 데이터 전체를 완전 탐색하는데, 만일 하나라도 빈 구멍(1)을 발견하면 즉시 false를 반환시켰습니다.(더이상 탐색할 필요가 없으므로) 이때 플레이어가 구멍 위에 있는 경우 지도 데이터 상 3으로 인식하므로 오리지널 지도 데이터를 활용하였습니다. 완전 탐색이 끝나도 구멍이 발견되지 않은 경우 게임을 클리어한 것으로 볼 수 있으므로 true를 반환시켜 while-true문으로부터 return시켜 다음 게임이 진행되도록 했습니다.
> > > ```Java
> > >     public boolean checkClear(int[][] data, int[][] map_data_origin){
> > >         for (int i = 0; i < data.length ; i++) {
> > >             for (int j = 0; j < data[0].length; j++) {
> > >                 if(data[i][j] == 1 || (data[i][j] == 3 && (map_data_origin[i][j] == 1 || map_data_origin[i][j] == 5))) return false;
> > >                 if(data[i][j] == 4) break; // 구분선인 경우 for문 탈출
> > >             }
> > >         }
> > >         return true;
> > >     }
> > > ```
  
<br/>
<hr/>
<br/>

> ### 실행 결과
> > #### 출력 시 고려사항
> > > + 특히 게임 프로그램의 경우 처음 코드를 작성한 후 갖가지 버그가 잠재되어 있을 수 있기 때문에 실제 게임 상의 Stage와 똑같이 구현하여 테스트를 여러번 진행해보았습니다.
> > >   + 대표적으로 아래 Stage 1의 경우 왼쪽으로 한칸 이동하면 게임이 쉽게 클리어 되지만 벽쪽으로 이동하면 인덱스 에러가 발생할 수 있었습니다. 왜냐하면 코드에서 플레이어 이동 시 바로 앞에 있는 물체만 인식하는 것이 아니라 그 다음 물체도 인식하고 있기 때문입니다. 그리하여 한 칸 더 앞에 있는 물체를 인식할 때의 인덱스가 지도 데이터 배열 인덱스를 초과하는 경우 0으로 초기화되도록 했습니다. 사실 인덱스가 초과된다는 것은 가장 바깥 벽을 보고 이동하는 경우 외에는 발생하지 않으므로 0으로 초기화시켜도 무방했습니다.
> > > ```
> > > #####
> > > #OoP#
> > > #####
> > > ```
> > >   + 또한 아래 Stage 3에서는 처음부터 구멍위에 공(5)이 있는 경우에는 현재 플레이어 위치에서 바로 한 칸(구멍(1) 쪽으로)내려가면 클리어가 되는 오류가 발생했는데, 이는 플레이어가 구멍(1)의 위치로 가면서 구멍(1) 위치에 3이 입력되면서 지도 상에 구멍(1)이 더이상 존재하지 않기 때문에 클리어가 되는 것이었습니다. 이를 해결하기 위해 클리어를 인식할 때 구멍(1)이 존재하는지만 보는 것이 아니라 플레이어가 있는 자리가 오리지날 지도 데이터 상 구멍이 있는 자리였는지 혹은 구멍 위에 공이있었던 자리였는지를 확인하도록 하여 개선시켰습니다.
> > > ```
> > > ###### 
> > > #P  ##
> > > #Oo0 #
> > > #  # #
> > > #    #
> > > ######
> > > ```
> > #### 실행 결과(1단계에서 지도 생성 시 지도 데이터 출력 부분 생략)
> > > ```
> > > Game Start!!
> > > Stage 1
> > > 
> > > #####
> > > #OoP#
> > > #####
> > > 
> > > 
> > > w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료), r(스테이지 초기화) 중 하나 이상 입력해주세요 : a
> > > 왼쪽으로 이동합니다. 현재 위치 ↓ 
> > > 현재 턴수 : 1
> > > 
> > > #####
> > > #0P #
> > > #####
> > > 
> > > 
> > > Stage 1 클리어!! 총 1 턴수가 소요되었습니다!!
> > > (...생략...)
> > >   #######  
> > > ###  O  ###
> > > #    o P  #
> > > # Oo   oO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > 
> > > 
> > > w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료), r(스테이지 초기화) 중 하나 이상 입력해주세요 : r
> > > 스테이지를 초기화 합니다.
> > >   #######  
> > > ###  O  ###
> > > #    o    #
> > > # Oo P oO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > (...생략...)
> > > Game Start!!
> > > Stage 5
> > > 
> > >   #### 
> > > ###  # 
> > > #P Oo##
> > > #   o #
> > > # #O  #
> > > #     #
> > > #######
> > > (...생략...)
> > > w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료), r(스테이지 초기화) 중 하나 이상 입력해주세요 : s
> > > 아래로 이동합니다. 현재 위치 ↓ 
> > > 현재 턴수 : 62
> > > 
> > >   #### 
> > > ###P # 
> > > #  0 ##
> > > #     #
> > > # #OoP#
> > > #     #
> > > #######
> > > w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽), q(게임 종료), r(스테이지 초기화) 중 하나 이상 입력해주세요 : a
> > > 왼쪽으로 이동합니다. 현재 위치 ↓ 
> > > 현재 턴수 : 63
> > > 
> > >   #### 
> > > ###  # 
> > > #  0 ##
> > > #     #
> > > # #0P #
> > > #     #
> > > #######
> > > 
> > > Stage 5 클리어!! 총 63 턴수가 소요되었습니다!!
> > > 
> > > 축하합니다!! 모든 스테이지를 클리어 했습니다!!
> > > ```

# 4단계 구현과정 상세 설명

## 4단계
> ### 풀이 과정
> > + #### 전체 클래스 구성
> >
> > >  + Sokoban 클래스(main 클래스)
> > >  + StageMap 클래스(지도 데이터 decrypt, 읽기, 출력)
> > >  + MapData 클래스(스테이지별 지도 데이터, 플레이어 위치 정보 저장 및 전송)
> > >  + GamePlay 클래스(지도 데이터 출력, 플레이어의 이동 및 조건, 초기화, 저장 및 불러오기, 되돌리기 등 부가 기능)
> > >  + Converter 클래스(main 클래스, txt 파일 encrypt)
> > >  + AESCryptoUtil 클래스(txt 파일 encrypt, dedecrypt)
> >	>
> > >  + 클래스 다이어그램
> > > ![캡처3](https://user-images.githubusercontent.com/82401504/145704133-d4aedc96-7b5d-4382-923b-d8dfba48815d.PNG)

> >
> > + #### 풀이 과정
> > + ##### 저장하기 불러오기 기능
> > >  + 우선 저장하기 기능을 구현하기 위해 File 객체를 생성하여 로컬에 txt 파일을 생성하여 해당 파일에 지도 데이터를 저장하고자 했습니다.
> > >    + 이때 BufferedWriter 생성하여 write 메서드를 통해 현재 지도 데이터(스테이지명, 플레이어의 위치 포함)를 해당 txt 파일에 한줄씩 입력하도록 했습니다. 또한, 나중에 불러오기를 통해 게임을 진행하는 경우를 대비하여 오리지날 지도 데이터 역시 해당 txt 파일에 입력하도록 했습니다.
> > >  + 그 다음 불러오기 기능을 구현하기 위해 BufferedReader 객체를 생성하여 로컬로부터 위에서 저장한 txt 파일을 불러와 이를 통해 얻어낸 지도 데이터를 현재 지도 데이터 객체(mapData)에 저장시켜주었습니다.
> > 
> > + ##### 지도 데이터 변환하기 프로그램
> > >  + 지도 데이터 map.txt 파일을 암호화(encrypt)하기 위해 우선 Converter 클래스(별도의 프로그램)를 새로 작성하였습니다. 해당 기능 구현에서는 AES 암호화 알고리즘을 사용했으며 key 값과 iv 파라미터 스펙은 16 바이트로 정해져있으므로 임의로 "Sokoban is good!"으로 명명하였습니다.
> > >  + 텍스트 파일을 암호화하고 암호 해독하는 메서드를 AESCryptoUtil 클래스에 작성했고 Converter 클래스에서 AESCryptoUtil 객체를 생성하여 로컬에 있는 map.txt 텍스트 파일을 암호화하도록 했습니다.
> > >  + 당초 StageMap 클래스 createMap 메서드에서는 Sokoban 프로그램이 실행될 때 로컬에서 map.txt 파일을 읽어와 지도 데이터를 생성했었지만 이번에는 AESCryptoUtil 객체를 생성하여 암호화된 파일을 읽어와 decrypt 메서드를 통해 암호 해독을 진행하도록 했습니다. 이후 해독이 된 파일을 다시 BufferedReader 객체를 생성하여 읽어와 원래대로 출력시켜주도록 했습니다.
> > >    + 이때 StageMap 클래스 역시 Converter 클래스의 key 값과 iv 파라미터스펙 값을 "Sokoban is good!"로 일치시켜주었습니다.
> > 
> > + ##### 되돌리기 기능 및 되돌리기 취소 기능 구현
> > > + 되돌리기 기능을 구현하기 위해 게임이 시작하는 동시에 현재 지도 데이터와 플레이어의 위치를 로깅해줄 필요가 있었습니다. 이를 위해 ArrayList 객체를 생성하여 게임 시작부터 플레이어가 이동함으로써 지도 데이터가 변경될때마다 현재 데이터를 해당 자료구조에 저장해주도록 했습니다.

<br/>
<hr/>
<br/>

> ### 코드 설명
> > 
> > + #### 저장하기 불러오기 기능
> > > ##### GamePlay 클래스(지도 데이터 출력, 플레이어의 이동 및 조건, 초기화, 저장 및 불러오기, 되돌리기 등 부가 기능)
> > >  + 저장하기 기능을 구현하기 앞서 명령어로 만일 1-5의 숫자를 받게 되면 현재 세이브 슬롯이 선택되도록 했습다. 이 세이브 슬롯은 ArrayList 자료구조의 인덱스를 가르키게 된다.(ArrayList의 크기를 6으로 지정함, 인덱스 0은 사용하지 않음) 만일 세이브 슬롯이 입력되지 않은채로 저장하기 메서드를 호출하면 동작하지 않도록 처리했습니다.
> > >    + saveMap 메서드에서는 슬롯 번호와 현재 지도 데이터, 해당 스테이지의 오리지날 데이터를 파라미터로 받는데, 이 정보를 모두 텍스트 파일에 저장하도록 함으로써 다음에 해당 세이브 게임을 불러오더라도 정상적으로 동작하도록 했습니다. 이때 File 객체를 생성하여 로컬 save 폴더에 해당 슬롯 번호의 제목으로 텍스트 파일을 생성시켜주었습니다. 텍스트 파일에 데이터를 입력할 때는 BufferWriter 객체를 생성하여 write 메서드를 사용했습니다.
> > >  + 불러오기 기능 역시 저장하기 기능과 마찬가지로 처음에 슬롯 번호를 받드시 입력받아야 동작하도록 구현했습니다. 여기서는 FileReader 객체를 생성하여 로컬 save 폴더에 저장되어있는 해당 슬롯 세이브 파일을 불러오도록 했고 BufferReader 객체를 생성하여 지도 데이터 등을 읽어와 현재 지도데이터로 바꿔주도록 했습니다.
> > >    + 이때 오리지날 지도 데이터의 경우 기존에 저장 및 전송 기능을 하는 MapData 클래스 필드로 존재하지 않았기 때문에 추가로 생성시켜주었습니다. 특히, 여기서는 배열 데이터를 주고받는 일이 많으므로 얕은 복사되지 않도록 배열을 새로 생성하여 값을 바꾸어주도록 했습니다.
> > > #### 지도 데이터 변환하기 프로그램
> > > ##### Converter 클래스(main 클래스, txt 파일 encrypt)
> > > + 지도 데이터를 암호화(encrypt) 하기 위해 AES 암호화 알고리즘을 사용했습니다. 이때 추후 해독하는 과정에서 정상적인 동작을 위해 key 값과 iv 파라미터스펙은 임의로 "Sokoban is good!"으로 명명했는데 해당 값들은 딱 16바이트에 맞춰서 작성해주어야 합니다. Paths을 통해 로컬에 있는 텍스트 파일을 불러오고 이를 encrypt하도록 했는데, 세부 encrypt 작업은 AES AESCryptoUtil 클래스에서 이루어집니다.
> > > ##### StageMap 클래스(지도 데이터 decrypt, 읽기, 출력)
> > > + StageMap 클래스에서는 당초 로컬에 있는 텍스트 파일를 읽어와 지도 데이터를 생성했었으나, 이번에는 Converter 프로그램에 의해 암호화된 파일을 해독( ecrypt)한 데이터를 읽어와 지도 데이터를 생성했습니다. Converter 클래스에서와 마찬가지로 key, specName, iv 라미터스펙 값을 일치시켜주었는데 만일 다를 경우 암호화된 데이터를 정상적으로 해독할 수 없게 됩니다. 마찬가지로 세부 decrypt 작업은 AESCryptoUtil 클래스에서 이루어집니다.
> > > ##### AESCryptoUtil 클래스(txt 파일 encrypt, dedecrypt)
> > > + AESCryptoUtil 클래스 encryptFile 메서드는 Converter 클래스로부터 전달받은 specName, key, iv 파라미터스펙 값을 파라미터로 받는데 이는 Cipher 클래스를 통해 암호화 기능을 수행하기 위함입니다. 우선 암호화 알고리즘은 AES로 설정했고 specName 값을 통해 Cipher 객체를 인스턴스화 시켜주었고(getInstance) Key 값과 iv 파라미터스펙 값을 통해 Cipher 객체를 초기화시켜주었습니다. 이후 CipherOutputStream 객체의 write 메서드를 통해 새로운 enc txt 파일에 암호화된 문자를 출력시켜주었습니다. 이때 암호화 시 기존 데이터의 개행문자가 사라지고 일렬로 늘어질 수 있으므로 읽어온 후 개행문자(\n)를 하나씩 더해주었습니다.
> > > + decryptFile 메서드 역시 StageMap 클래스로부터 specName, key, iv 파라미터스펙 값을 파라미터로 받습니다. 이유는 위와 같습니다. Cipher 객체를 인스턴스화 시키고 초기화 시키는 작업은 동일하지만 초기화 시 decrypt 모드로 설정해주어야 정상적으로 동작합니다. 이후 FileOutputStream 객체의 write 메서드를 통해 새로운 dec txt 파일에 해독된 문자를 출력시켜주었습니다. 마찬가지로 암호 해독 시 기존 데이터의 개행문자가 사라지고 일렬로 늘어질 수 있으므로 읽어온 후 개행문자(\n)를 하나씩 더해주었습니다.
> > > #### 되돌리기 기능 및 되돌리기 취소 기능 구현
> > > ##### GamePlay 클래스(지도 데이터 출력, 플레이어의 이동 및 조건, 초기화, 저장 및 불러오기, 되돌리기 등 부가 기능)
> > > + 명령어 u 또는 U를 받으면 goBackOrForward 메서드가 동작하도록 했는데 해당 메서드에서 만일 한 턴 되돌리기 명령어 u를 입력하면 현재 턴수를 1 감소시켜 그 턴수에 해당하는 지도 데이터와 플레이어의 위치 데이터를 불러오도록 했고, 되돌리기 취소 명령어 U를 입력하면 현재 턴수를 1 증가시켜 그 턴수에 해당하는 지도 데이터와 플레이어의 위치 데이터를 불러오도록 했습니다.

> ### 실행 결과
> > #### 출력 시 고려사항
> > > ##### 저장하기 불러오기 기능
> > > + 세이브 파일을 저장할 때는 별도의 세이브 폴더를 만들어주어 관리하도록 했습니다. 또한 직관적으로 알 수 있도록 해당 세이브 슬롯의 번호대로 파일이 저장되도록 했습니다. 특히, 단순 저장하고 불러오는 작업은 단순해도 이를 불러온 이후로 게임을 진행한다면 갖가지 오류가 발생했습니다. 예를 들어 스테이지 3을 진행하는 중에 세이브된 스테이지 2 파일을 불러온다면 기존의 오리지날 지도 데이터나 로깅했던 데이터, 턴수 등이 새로운 지도 데이터와 충돌하기 때문에 세이브 파일을 불어올 때마다 그 스테이지에 맞게, 그 상황에 맞게 초기화시켜주어야 했습니다.
> > > ##### 실행결과
> > > ```Java
> > > ※ 부가 기능 : q(게임 종료), r(스테이지 초기화), u(한 턴 되돌리기), U(턴 되돌리기 취소), 1~5(세이브 슬롯 선택), S(세이브), L(불러오기)
> > > 명령어 w(위쪽), a(왼쪽), s(아래쪽), d(오른쪽) 중 하나 이상 입력해주세요. : 1L
> > > 1번 세이브 슬롯 선택
> > > 
> > > Stage 2
> > >   #######  
> > > ###  O  ###
> > > #   Po    #
> > > # Oo   oO #
> > > ###  o  ###
> > >  #   O  #  
> > >  ########  
> > > 
> > > 
> > > 1번 세이브 슬롯으로부터 데이터를 불러왔습니다. 현재 턴수 : 0
> > > ```
> > > ##### 지도 데이터 변환하기 프로그램
> > > + 암호화 한 후 해독하는 과정에서 key, specName, iv 파라미터스펙 값 중 하나라도 다르면 해독 자체가 안되거나(key) 어느 정돈 해독해도 불완전하게(iv 파라미터스펙 값) 됩니다. 이를 위해 해당 값들을 난수 알고리즘을 통해 얻지 않고 일단 Converter 클래스에서 각 값을 문자열로 정의한 후 이를 인자로 두어 AESC 클래스에 전달해주었습니다. StageMap 클래스 역시 마찬가지로 작업을 진행해주었습니다. String으로 전달받은 AESC 클래스 각각의 메서드들은 이를 활용하여 SecretKeySpec 객체를 생성하거나 IvParameterSpec 객체를 생성함으로써 파일 암호화와 복호화를 진행해주었습니다.
> > > ##### 되돌리기 기능 및 되돌리기 취소 기능 구현
> > > + 처음 게임이 진행된 후 플레이어를 이동시킨 후 되돌리기하고 되돌리기 취소 기능을 하면 정상적으로 작동하지만 되돌리기 기능을 한 후에 플레이어를 몇 번 이동시킨 후 다시 되돌리기를 하다보면 직전에 있는 위치로 가는게 아니라 몇 단계 전으로 이동하게 되는 버그가 발생했습니다. 이 원인은 되돌리기 시 턴수가 1씩 감소하는데 이 턴수를 기준으로 List 자료구조로부터 데이터를 가져오기 때문입니다. 이때 플레이어가 추가로 움직이게 된다면 가장 최근에 생겼던 로깅 데이터를 가져와야 되는데 인덱스 상 한참 전인 턴수에 해당하는 데이터를 가져오기 때문입니다. 이를 개선하기 위해서는 되돌리기 후 플레이어가 이동 시 기존 로깅 데이터를 초기화하는 작업이 필요했습니다. 개선된 코드는 다음과 같습니다.
> > > ```Java
> > > // 기존 코드
> > > mapData = checkCommand(command, stage_name, map_data, map_data_origin, player_pos);
> > > if(!(mapData == null)) turn++;
> > > else continue;
> > > System.out.printf("현재 턴수 : %d%n%n", turn);
> > > showMap(map_data);
> > > 
> > > row = map_data.length;
> > > col = map_data[0].length;
> > > // 변경된 지도 데이터와 플레이어의 위치 로깅 작업
> > > map_data_log = new int[row][col];
> > > for (int j = 0; j < row; j++) for (int k = 0; k < col; k++) map_data_log[j][k] = map_data[j][k];
> > > player_pos_log = new int[]{player_pos[0], player_pos[1]};
> > > map_log.add(map_data_log);
> > > player_log.add(player_pos_log);
> > > 
> > > if(checkClear(map_data, map_data_origin) == true) {
> > >     System.out.printf("%s 클리어!! 총 %d 턴수가 소요되었습니다!!%n%n", stage_name, turn);
> > >     return false;
> > > }
> > > // 개선된 코드
> > > mapData = checkCommand(command, stage_name, map_data, map_data_origin, player_pos);
> > > if(mapData == null) continue;
> > > else {
> > >     showMap(map_data);
> > >     int loop = map_log.size() - 1;
> > >     while (loop > turn) {
> > >         map_log.remove(loop);
> > >         player_log.remove(loop);
> > >         loop--;
> > >     }
> > > }
> > > 
> > > // 변경된 지도 데이터와 플레이어의 위치 로깅 작업
> > > row = map_data.length;
> > > col = map_data[0].length;
> > > map_data_log = new int[row][col];
> > > for (int j = 0; j < row; j++) for (int k = 0; k < col; k++) map_data_log[j][k] = map_data[j][k];
> > > player_pos_log = new int[]{player_pos[0], player_pos[1]};
> > > map_log.add(map_data_log);
> > > player_log.add(player_pos_log);
> > > turn++;
> > >
> > > System.out.printf("현재 턴수 : %d%n", turn);
> > > if(checkClear(map_data, map_data_origin) == true) {
> > >     System.out.printf("%s 클리어!! 총 %d 턴수가 소요되었습니다!!%n%n", stage_name, turn+1);
> > >     return false;
> > > }
> > > ```
> > > 
> > > + 위 코드에서 바뀐점은 우선 명령어(w, a, s, d)에 따라 플레이어의 위치가 변경된 후 바뀐 상태를 로깅만 해주었던 기존 코드와 달리 개선된 코드에서는 바뀐 상태를 로깅하기 전 현재 턴수를 기준으로 로깅 리스트 내 인덱스가 더 많은 요소가 존재한다면 이를 while 반복문으로 제거시켜주는 작업을 해주었습니다. 그리고 나서 로깅 작업을 해주도록 했습니다. 이에 플레이어의 위치가 변경되자마자 턴수(turn)를 증가시켜주는 게 아니라 로깅 작업이 이루어지고나서 턴수를 증가시켜주었습니다.(턴수를 앞에서 증가시켜주면 while 반복문 내에서 인덱스 에러가 나기 때문)
> > >   + 플레이어가 이동을 한 시점에는(되돌리기 취소를 해서 당초 턴수보다 낮을지라도) 그 시점이 가장 최신의 지도 데이터이기 때문에 그 상태에서는 되돌리기 취소라는 것이 존재할 수 없습니다. 그렇기 때문에 현재 턴수를 초과하는 로깅 자료가 있다면 삭제하는 것이 마땅했습니다. 즉, 위에서 일어났던 버그는 되돌리기 취소라는 것이 되돌리기가 난 후에만 존재해야한다는 것을(어떻게 보면 당연한 것이지만) 인지하지 못했기 때문이었습니다.
